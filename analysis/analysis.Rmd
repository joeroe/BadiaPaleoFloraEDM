---
title: Ecological niche models of plant species exploited by Epipalaeolithic foragers
  in the *Badia* (c. 14500 BP)
output:
  html_document:
    df_print: paged
  pdf_document:
    latex_engine: xelatex
---

## Dependencies

```{r packages, warning=FALSE, message=FALSE}
library("tidyverse")
library("magrittr")
library("sf")
library("raster")
library("broom")
library("dismo")
library("rnaturalearth")
library("gt")
library("BadiaPaleoFloraENM")
```

## Introduction

Species distribution models (SDM) or ecological niche models (ENM) use data on the observed occurrences of a taxon to construct a statistical model of its ecological niche.
These models are generally then used to predict the distribution of the species in another context, e.g. a region where empirical occurrence data is not available, or under past or future climate regimes.
We will attempt to model the ecological niches of six key plant taxa for prehistoric foragers.
We will use occurrence data from Israel and Palestine, which are well-studied, to predict the distribution of these taxa across the rest of the Southern Levant.

First, we define our regions of interest:

```{r regions, warning=FALSE, message=FALSE}
sw_asia <- extent(c(30, 50, 25, 40))
s_levant <- extent(c(34, 39, 29, 34))
palestine <- ne_countries(scale = 10, country = c("Israel", "Palestine"),
             returnclass = "sf") %>% st_union() %>% st_sf()

land <- read_sf("data/raw_data/ne/ne_10m_land.shp")[,"featurecla"] %>%
  st_crop(sw_asia)
rivers <- read_sf("data/raw_data/ne/ne_10m_rivers_lake_centerlines_scale_rank.shp") %>% 
  st_crop(s_levant)
water <- rbind(read_sf("data/raw_data/ne/ne_10m_ocean.shp")[,"featurecla"],
               read_sf("data/raw_data/ne/ne_10m_lakes.shp")[,"featurecla"]) %>% 
  st_crop(sw_asia)
```

```{r regions-map, echo=FALSE, results='hide'}
basemap <- ggplot() + 
  geom_sf(data = land, fill ="grey") +
  geom_sf(data = palestine, fill = "lightgrey") + 
  geom_sf(data = rivers, colour = "white") +
  geom_sf(data = water, fill = "white") +
  coord_sf(xlim = c(xmin(s_levant), xmax(s_levant)),
           ylim = c(ymin(s_levant), ymax(s_levant)))
basemap
```

## Occurrence data

First we download species occurrence data from GBIF (<https://gbif.org>).
This may change, so we cache the result used in the published analysis in `derived_data` and only redownload if the cached version is missing.

```{r occurrence-data, warning=FALSE, message=FALSE}
# Download or read data from GBIF
gbif_path <- here::here("analysis/data/raw_data/gbif")
occ <- bind_rows(
  fetch_gbif("Hordeum", "spontaneum*", ext = sw_asia, gbif_path),
  fetch_gbif("Bolboschoenus", "glaucus*", ext = sw_asia, gbif_path),    
  fetch_gbif("Bolboschoenus", "maritimus*", ext = sw_asia, gbif_path),    
  fetch_gbif("Scirpus", "maritimus*", ext = sw_asia, gbif_path),
  fetch_gbif("Triticum", "urartu*", ext = sw_asia, gbif_path),
  fetch_gbif("Triticum", "dicoccoides*", ext = sw_asia, gbif_path),
  fetch_gbif("Stipa", "*", ext = sw_asia, gbif_path),
  fetch_gbif("Zilla", "spinosa*", ext = sw_asia, gbif_path),
  fetch_gbif("Vitex", "*", ext = sw_asia, gbif_path),
  fetch_gbif("Fraxinus", "*", ext = sw_asia, gbif_path)
)

# Code taxonomic groups for analysis
occ %>% 
  mutate(taxon = case_when(genus == "Hordeum" ~ "Hordeum spontaneum",
                           genus == "Bolboschoenus" ~ "Bolboschoenus sp. (=Scirpus maritimus)",
                           species == "Triticum urartu" ~ "Triticum urartu",
                           species == "Triticum dicoccoides" ~ "Triticum dicoccoides",
                           genus == "Stipa" ~ "Stipa sp.",
                           genus == "Zilla" ~ "Zilla spinosa",
                           genus == "Vitex" ~ "Vitex sp.",
                           genus == "Fraxinus" ~ "Fraxinus sp.")) %T>%
  {if(any(is.na(.$taxon))) stop("Taxon contains missing values!")} ->
  occ


# Remove duplicate records within analytic groups
occ %>% 
  group_by(taxon) %>% 
  distinct(lon, lat, .keep_all = TRUE) %>% 
  ungroup() ->
  occ

# Convert to sf
occ %>% 
  st_as_sf(coords = c("lon", "lat"), crs = 4326, remove = FALSE) ->
  occ
```

It's interesting to map the current distribution of these plants.
```{r occurrence-map, echo=FALSE, results='hide'}
ggplot(occ, aes(x = lon, y = lat)) +
  geom_sf(data = occ, shape = 1, size=0.5) +
  geom_sf(data = water, inherit.aes = FALSE, fill = "white", colour = "darkgrey") +
  facet_wrap(~taxon)
```

## Pseudo-absences

Occurrence data only tells us where a species is present;
there is no definitive information on where the species is *not* found.
We therefore need to generate random background points or "pseudo-absences" to feed to the model.
There are several ways to do this. 
We follow the advice of Barbet-Massin et al. (2012) for regression-based species distribution models and simply use a large (~10000) random sample of points.

```{r psabsences, warning=FALSE, message=FALSE}
occ <- as_tibble(occ)
occ$occurrence <- TRUE
for(taxon in unique(occ$taxon)) {
  occ <- bind_rows(occ, generate_psabsences(palestine, taxon = taxon,
                                            occurrence = FALSE, N = 10000))
}
occ <- sf::st_as_sf(occ, crs = 4326)
rm(taxon)
```

## Environmental data

### Bioclimatic variables

To construct the model, we'll use a standard set of "bioclimatic" predicator variables.
These sixteen variables are derived from monthly precipitation and temperate data:

```{r bioclim-table, echo=FALSE}
tibble(biovar = paste0("bio", 1:16),
       definition = c("Mean annual temperature",
                      "Mean diurnal range",
                      "Isothermality",
                      "Temperature seasonality",
                      "Maximum temperature of warmest month",
                      "Minimum temperature of coldest month",
                      "Annual temperature range",
                      "Mean temperature of wettest quarter",
                      "Mean temperature of driest quarter",
                      "Mean temperature of warmest quarter",
                      "Mean temperature of coldest quarter",
                      "Total annual precipitation",
                      "Precipitation of wettest month",
                      "Precipitation of driest month",
                      "Precipitation seasonality",
                      "Precipitation of wettest quarter"),
       formula = c("",
                   "",
                   "(bio2 / bio7) * 100",
                   "sd(temp) * 100",
                   "",
                   "",
                   "bio5 - bio6",
                   "",
                   "",
                   "",
                   "",
                   "",
                   "",
                   "",
                   "",
                   "")
) %>%
  gt()
```

Here the climate data is from WorldClim 1.4 (<http://www.worldclim.org>), a global dataset compiled from weather station records from the period 1960–1990.
WorldClim has been widely used in ecological niche modelling.
Other global climate datasets (e.g. CHELSA, MERRAClim) and a newer version of WorldClim are now available, so it may be a good idea to investigate using these instead.
The WorldClim data is large so again it is cached in the package's `derived_data` directory.

```{r bioclim-data, echo=FALSE}
# bioclim <- get_bioclim(s_levant, resolution = 0.5, cache_path = "data/derived_data")
# Workaround for memory problems in Safawi
load("data/derived_data/bioclim.RData")
plot(bioclim)
```

### Soil variables

Velazco et al. (2017) have shown that edaphic data, recently available on a global scale, is usefully combined with bioclimatic data in modelling plant niches.

We use data from SoilGrids, a global map of soil characteristics derived from remote sensing classification at 1km resolution.

```{r soil-data}
soilgrids <- raster::stack(list.files("data/raw_data/soilgrids", ".*tif", full.names = TRUE))
plot(soilgrids)
```

### Terrain

There are also relevent aspects of the terrain that can be easily derived from a digital elevation model.
We'll use NASA-JPL's SRTM v3 1 arc-second resolution DEM.

### Selection of predictor variables

We reviewed existing floras to identify specific variables from these datasets that are relevant to the niche of our target taxa. The results are summarised below.

```{r review-table, echo=FALSE, warning=FALSE, message=FALSE}
read_csv("data/raw_data/flora_review.csv") %>% 
  group_by(Taxon) %>% 
  gt()
```

Based on these results, we made the following initial selection of predictor variables to build the models.

```{r predictor-table, echo=FALSE}
pred <- bind_rows(
  tibble(group = rep("Climate", 5),
         variable = c("Minimum temperature of coldest month",
                      "Total annual precipitation", "Precipitation of wettest month",
                      "Precipitation of driest month", "Precipitation seasonality"),
         units = c("°C ×10", "mm", "mm", "mm", "σ/μ"),
         source = rep("WorldClim 1.4", 5),
         code = c("bio6", "bio12", "bio13", "bio14", "bio15"),
         raster = as.list(raster::subset(bioclim,
                                         c("bio6", "bio12", "bio13", "bio14", "bio15")))),
  tibble(group = rep("Soil", 5),
         variable = c("Organic carbon content", "Coarse fragment content",
                      "Sand content", "Acidity", "Depth to bedrock"),
         units = c("g per kg fine earth", "% volume", "% mass", "pH ×10 in H2O",
                   "cm (up to 200 cm)"),
         source = rep("SoilGrids250m", 5),
         code = c("ORCDRC_M_sl2_250m", "CRFVOL_M_sl2_250m", "SNDPPT_M_sl2_250m",
                  "PHIHOX_M_sl2_250m", "BDRICM_M_250m"),
         raster = as.list(raster::subset(soilgrids,
                                         c("ORCDRC_M_sl2_250m", "CRFVOL_M_sl2_250m", "SNDPPT_M_sl2_250m",
                  "PHIHOX_M_sl2_250m", "BDRICM_M_250m"))))
  # tibble(group = rep("Terrain", 3),
  #        variable = c("Elevation", "Slope", "Topographic Wetness Index"),
  #        units = c("m", "°", "ln(upslope area / tan(slope))"),
  #        source = rep("SRTM DEM v3", 3),
  #        code = c("srtm1v3_slevant", "srtm1v3_slevant_slope",
  #                         "srtm1v3_slevant_twi"))
)

pred %>%
  dplyr::select(-raster) %>% 
  group_by(group) %>% 
  gt()
```

One aspect that we cannot easily incorporate into the models is the interaction between these taxa and other plant and animal species: cereal grasses grow best when they have no competition from perennial plants, *Fraxinus* often grows in scrub or forest, and so on.

We also lack data for soil salinity so far.

### Combining predictor variables

These datasets come with different resolutions.
To use them all in the same analysis, we resample them all to the finest dataset (WorldClim, 30 arc-seconds).

```{r predictor-resample}
pred$raster <- lapply(pred$raster, raster::resample, y = bioclim, method = "ngb")
```

## Model construction

We will model the ecological niche of each species using a generalised linear regression.

First we extract the values of the predictor variables at each occurrence and pseudo-absence location:

```{r predictor-extraction}
# TODO: refactor to use pred
bioclim %>% 
  raster::extract(as_Spatial(occ)) %>% 
  {cbind(occ, .)} %>% 
  st_as_sf(crs = st_crs(occ)) ->
  occ

soilgrids %>% 
  raster::extract(as_Spatial(occ)) %>% 
  {cbind(occ, .)} %>% 
  st_as_sf(crs = st_crs(occ)) ->
  occ
```

### Species response curves

We can use species response curves to visualise the distribution of known occurrences in relation to these environmental gradients.
This will also help us parameterise the ecological niche models.

Species response curves are constructed with a simple logistic regression, fitting the probability of occurrence at a given location to 
The use of a linear regression assumes a unimodal response.
We fit first, second, and third order polynomial models to each species/predictor combination and calculate the Akaike Information Criterion (AIC).

```{r response-curves-fit, warning=FALSE, message=FALSE}
# Summarise occurrences on a grid
palestine %>% 
  as_Spatial() %>% 
  raster::rasterize(bioclim) ->
  palestine_raster

occ %>% 
  filter(occurrence == TRUE) %>% 
  group_by(taxon) %>% 
  do(occ_grid = raster_burn(., palestine_raster)) ->
  occ_grids

# Fit poly(1:3) to each taxon/predictor combination
expand.grid(taxon = unique(occ$taxon),
            predictor = pred$code,
            polyn = 1:3) %>% 
  group_by(taxon, predictor, polyn) %>% 
  do(
    # TODO: It works but I hate it.
    fit = model_response(unlist(occ_grids[occ_grids$taxon == .$taxon, "occ_grid"])[[1]],
                         unlist(pred[pred$code == .$predictor, "raster"])[[1]],
                         .$polyn)
  ) %>% 
  glance(fit) -> 
  response_glm
```

```{r response-curves-table, echo=FALSE}
# response_glm %>% 
#   spread(polyn, aic) %>% 
#   rename(aic_poly1 = `1`, aic_poly2 = `2`, aic_poly3 = `3`) %>% 
#   gt(rowname_col = "predictor", groupname_col = "taxon") %>% 
#   tab_stubhead_label("predictor")
```

The optimal model is the one with the lowest AIC.

```{r response-curves-optimal}
response_glm %>%
  group_by(taxon, predictor) %>%
  mutate(optimum = polyn == which.min(AIC)) ->
  response_glm

# TODO
# Re-fit and plot optimal 
# model_response(occ_grids$occ_grid[[1]], pred$raster[[1]], 2) %>% predict(data.frame(pred = -72:109, type = "response")) %>% plot()
# Need to dplyrise this – see broom::augment()
# response_glm %>% 
#   filter(optimum == TRUE) %>% 
#   slice(1:3) %>% 
#   do(
#     fit = model_response(unlist(occ_grids[occ_grids$taxon == .$taxon, "occ_grid"])[[1]],
#                          unlist(pred[pred$code == .$predictor,"raster"])[[1]],
#                          .$polyn)
#   ) 
```

### Model fitting

Now we can fit regression models combining all the predictor variables.

```{r model_fit, warning=FALSE, message=FALSE}
# TODO: use optimal polynomial order
occ %>% 
  group_by(taxon) %>% 
  remove_missing(vars = c("bio1", "bio2", "bio3", "bio4", "bio5", "bio6", 
                          "bio7", "bio8", "bio9", "bio10", "bio11", "bio12", 
                          "bio13", "bio14", "bio15", "bio16", "bio17", "bio18", 
                          "bio19", "BDRICM_M_250m", "CRFVOL_M_sl2_250m", 
                          "ORCDRC_M_sl2_250m", "PHIHOX_M_sl2_250m", 
                          "SNDPPT_M_sl2_250m")) %>% 
  do(model = glm(occurrence ~ 
                   poly(bio6, 2) +
                   poly(bio12, 2) +
                   poly(bio13, 2) +
                   # poly(bio14, 2) +
                   poly(bio15, 2) +
                   poly(BDRICM_M_250m, 2) +
                   poly(CRFVOL_M_sl2_250m, 2) +
                   poly(ORCDRC_M_sl2_250m, 2) + 
                   poly(PHIHOX_M_sl2_250m, 2) + 
                   poly(SNDPPT_M_sl2_250m, 2),
                 data = .)) ->
  models

```


## Predicting occurrences
### Current conditions

We can now use the fitted models to predict the occurrence of the different taxa according to the predictor variables.
Initially, we do this based on current conditions.
This allows us to extrapolate from regions with good occurrence data (i.e. Israel/Palestine) to those without.
It also hints at what the distribution of the plant might be under "ideal conditions", without agriculture, grazing, etc.

```{r pred_current}
models %>% 
  do(taxon = .$taxon,
     model = .$model,
     pred_current = raster::predict(object = raster::stack(pred$raster),
                                    model = .$model)) ->
  models
```

```{r pred_current_plot, echo=FALSE}
raster::stack(models$pred_current) %>%
  set_names(models$taxon) %>% 
  plot()
```

### Binning

To more easily interpret these predictions, we could convert the raw probability scores into confidence intervals, based on the proportion of known occurrences it successfully predicts.

```{r binning}
raster::stack(models$pred_current) %>%
  set_names(paste0("pred_current_", models$taxon)) %>% 
  raster::extract(as_Spatial(occ)) %>% 
  {cbind(occ, .)} %>% 
  st_as_sf(crs = st_crs(occ)) ->
  occ2
```
