---
title: Ecological niche models of plant species exploited by Epipalaeolithic foragers
  in the *Badia* (c. 14500 BP)
output:
  pdf_document: 
    latex_engine: xelatex
  html_document:
    df_print: paged
---

```{r packages, include=FALSE}
library("tidyverse")
library("magrittr")
library("sf")
library("stars")
library("parallel")
library("broom")
library("dismo")
library("rnaturalearth")
library("gt")
library("viridis")
library("BadiaPaleoFloraENM")
```

```{r defs, include=FALSE}
latlong <- 4326
utm37n <- 32637
```

## Introduction

Species distribution models (SDM) or ecological niche models (ENM) use data on the observed occurrences of a taxon to construct a statistical model of its ecological niche.
These models are generally then used to predict the distribution of the species in another context, e.g. a region where empirical occurrence data is not available, or under past or future climate regimes.
We will attempt to model the ecological niches of six key plant taxa for prehistoric foragers.
We will use occurrence data from Israel and Palestine, which are well-studied, to predict the distribution of these taxa across the rest of the Southern Levant.

First, we define our regions of interest:

```{r regions, include=FALSE}
sw_asia <- extent(c(30, 50, 25, 40))
s_levant <- extent(c(34, 39, 29, 34))

ne_countries(scale = 10, country = c("Israel", "Palestine"), returnclass = "sf") %>% 
  st_union() ->
  palestine

read_sf("data/raw_data/ne/ne_10m_land.shp")[,"featurecla"] %>%
  st_crop(sw_asia) -> 
  land

rivers <- read_sf("data/raw_data/ne/ne_10m_rivers_lake_centerlines_scale_rank.shp") %>% 
  st_crop(s_levant)

water <- rbind(read_sf("data/raw_data/ne/ne_10m_ocean.shp")[,"featurecla"],
               read_sf("data/raw_data/ne/ne_10m_lakes.shp")[,"featurecla"])
```

```{r regions-map, echo=FALSE}
ggplot() + 
  geom_sf(data = palestine, fill = viridis(2)[2], colour = NA) +
  geom_sf(data = rivers, colour = "#999999") +
  geom_sf(data = water, fill = "#eeeeee", colour = "#999999") +
  coord_sf(xlim = c(xmin(s_levant), xmax(s_levant)),
           ylim = c(ymin(s_levant), ymax(s_levant))) +
  theme_bw()
```

## Background

### Plant exploitation in the Epipalaeolithic Southern Levant

### Ecological niche modelling

## Data

### Occurrences

First we download species occurrence data from GBIF (<https://gbif.org>).
This may change, so we cache the result used in the published analysis in `derived_data` and only redownload if the cached version is missing.

```{r occurrence-data, include=FALSE}
# Download or read data from GBIF
# TODO: T. boeoticum ? (equate with T. urartu?)
gbif_path <- here::here("analysis/data/raw_data/gbif")
occ <- bind_rows(
  fetch_gbif("Hordeum", "spontaneum*", ext = sw_asia, gbif_path),
  fetch_gbif("Bolboschoenus", "glaucus*", ext = sw_asia, gbif_path),    
  fetch_gbif("Bolboschoenus", "maritimus*", ext = sw_asia, gbif_path),    
  fetch_gbif("Scirpus", "maritimus*", ext = sw_asia, gbif_path),
  fetch_gbif("Triticum", "urartu*", ext = sw_asia, gbif_path),
  fetch_gbif("Triticum", "dicoccoides*", ext = sw_asia, gbif_path),
  fetch_gbif("Stipa", "*", ext = sw_asia, gbif_path),
  fetch_gbif("Zilla", "spinosa*", ext = sw_asia, gbif_path),
  fetch_gbif("Vitex", "*", ext = sw_asia, gbif_path),
  fetch_gbif("Fraxinus", "*", ext = sw_asia, gbif_path)
)

# Code taxonomic groups for analysis
occ %>% 
  mutate(taxon = case_when(genus == "Hordeum" ~ "Hordeum spontaneum",
                           genus == "Bolboschoenus" ~ "Bolboschoenus sp.",
                           species == "Triticum urartu" ~ "Triticum urartu",
                           species == "Triticum dicoccoides" ~ "Triticum dicoccoides",
                           genus == "Stipa" ~ "Stipa sp.",
                           genus == "Zilla" ~ "Zilla spinosa",
                           genus == "Vitex" ~ "Vitex sp.",
                           genus == "Fraxinus" ~ "Fraxinus sp.")) %T>%
  {if(any(is.na(.$taxon))) stop("Taxon contains missing values!")} ->
  occ


# Remove duplicate records within analytic groups
occ %>% 
  group_by(taxon) %>% 
  distinct(lon, lat, .keep_all = TRUE) %>% 
  ungroup() ->
  occ

# Convert to sf
occ %>% 
  st_as_sf(coords = c("lon", "lat"), crs = 4326, remove = FALSE) ->
  occ
```

It's interesting to map the current distribution of these plants.
```{r occurrence-map, echo=FALSE}
ggplot(occ, aes(x = lon, y = lat)) +
  geom_sf(data = water, inherit.aes = FALSE, fill = "#eeeeee", colour = "#999999") +
  geom_sf(data = occ, shape = 1, size=0.5) +
  coord_sf(xlim = c(xmin(sw_asia), xmax(sw_asia)),
           ylim = c(ymin(sw_asia), ymax(sw_asia))) +
  facet_wrap(~taxon) +
  theme_bw() +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank())
```

### Pseudo-absences

Occurrence data only tells us where a species is present;
there is no definitive information on where the species is *not* found.
We therefore need to generate random background points or "pseudo-absences" to feed to the model.
There are several ways to do this. 
We follow the advice of Barbet-Massin et al. (2012) for regression-based species distribution models and use a large (~10000) random sample of points, weighted equally against the presences in the regression.

```{r psabsences, include=FALSE}
n_psab <- 10000

occ <- as_tibble(occ)
occ$occurrence <- TRUE
for(taxon in unique(occ$taxon)) {
  occ <- bind_rows(occ, generate_psabsences(palestine, taxon = taxon,
                                            occurrence = FALSE, N = n_psab))
}
occ <- sf::st_as_sf(occ, crs = 4326)
rm(taxon)

# Weights
occ %>% 
  group_by(taxon, occurrence) %>% 
  mutate(weight = 1 + (n_psab / n() - 1)) ->
  occ
```

### Environmental data

#### Current climate

To construct the model, we'll use a standard set of "bioclimatic" predicator variables.
These sixteen variables are derived from monthly precipitation and temperate data:

```{r bioclim-table, echo=FALSE}
tibble(biovar = paste0("bio", 1:19),
       definition = c("Mean annual temperature",
                      "Mean diurnal range",
                      "Isothermality",
                      "Temperature seasonality",
                      "Maximum temperature of warmest month",
                      "Minimum temperature of coldest month",
                      "Annual temperature range",
                      "Mean temperature of wettest quarter",
                      "Mean temperature of driest quarter",
                      "Mean temperature of warmest quarter",
                      "Mean temperature of coldest quarter",
                      "Total annual precipitation",
                      "Precipitation of wettest month",
                      "Precipitation of driest month",
                      "Precipitation seasonality",
                      "Precipitation of wettest quarter",
                      "Precipitation of driest quarter",
                      "Precipitation of warmest quarter",
                      "Precipitation of coldest quarter"),
       formula = c("",
                   "",
                   "(bio2 / bio7) * 100",
                   "sd(temp) * 100",
                   "",
                   "",
                   "bio5 - bio6",
                   "",
                   "",
                   "",
                   "",
                   "",
                   "",
                   "",
                   "",
                   "",
                   "",
                   "",
                   "")
) %>%
  gt()
```

Here the current bioclimatic data is from CHELSA (<http://chelsa-climate.org/bioclim/>).

```{r bioclim-data, include=FALSE}
fetch_paleoclim("cur", "2_5m", s_levant,
                "./data/derived_data/paleoclim/paleoclim_cur.grd") %>% 
  st_as_stars() ->
  bioclim
```

#### Palaeoclimate

```{r paleoclim-data, include=FALSE}
tibble(
  period_code = c("eh", "yds", "ba", "hs1", "lgm"),
  period = c("Early Holocene", "Younger Dryas", "Bølling-Allerød", "Heinrich 1", "Last Glacial Maximum"),
  raster = c(
    fetch_paleoclim("eh", "2_5m", s_levant, 
                    "./data/derived_data/paleoclim/paleoclim_eh.grd"),
    fetch_paleoclim("yds", "2_5m", s_levant, 
                    "./data/derived_data/paleoclim/paleoclim_yds.grd"),
    fetch_paleoclim("ba", "2_5m", s_levant, 
                    "./data/derived_data/paleoclim/paleoclim_ba.grd"),
    fetch_paleoclim("hs1", "2_5m", s_levant, 
                    "./data/derived_data/paleoclim/paleoclim_hs1.grd"),
    fetch_paleoclim("lgm", "2_5m", s_levant, 
                    "./data/derived_data/paleoclim/paleoclim_lgm.grd")
  )
) %>% 
  mutate(raster = st_as_stars(raster)) ->
  paleoclim
```

### Soil

Velazco et al. (2017) have shown that edaphic data, recently available on a global scale, is usefully combined with bioclimatic data in modelling plant niches.

We use data from SoilGrids, a global map of soil characteristics derived from remote sensing classification at 1km resolution.

```{r soil-data, include=FALSE}
soilgrids <- raster::stack(list.files("data/raw_data/soilgrids", ".*tif",
                                      full.names = TRUE))
```

### Terrain

There are also relevent aspects of the terrain that can be easily derived from a digital elevation model.
We'll use NASA-JPL's SRTM v3 3 arc-second resolution DEM, smoothed with Sun's denoising algorithm [TODO: CITE].
Slope was calculated from this surface using GDAL 3.0.0 and the topographic wetness index (TWI) using the r.topidx module of GRASS 7.8.
The DEM was reprojected to a conformal projection (Jordan Transverse Mercator, EPSG:19995) for these calculations, using a bilinear interpolation, then back to geographic coordinates.

```{r terrain-data, include=FALSE}
raster::stack(paste0("./data/raw_data/srtm/",
                     c("srtm3v3s_slevant.tif",
                       "srtm3v3s_slevant_slope.tif",
                       "srtm3v3s_slevant_twi.tif"))) %>% 
  set_names(c("elev", "slope", "twi")) ->
  terrain
```

## Model

### Selection of predictors

We reviewed existing floras to identify specific variables from these datasets that are relevant to the niche of our target taxa. The results are summarised below.

```{r review-table, echo=FALSE}
read_csv("data/raw_data/flora_review.csv") %>% 
  group_by(Taxon) %>% 
  # TODO: add refs
  dplyr::select(-Reference) %>% 
  gt()
```

Based on these results, we made the following initial selection of predictor variables to build the models.

```{r predictor-table, echo=FALSE}
pred <- bind_rows(
  tibble(group = rep("Climate", 4),
         time = rep("now", 4),
         variable = c("Minimum temperature of coldest month",
                      "Total annual precipitation", "Precipitation of wettest month",
                      "Precipitation seasonality"),
         units = c("°C ×10", "mm", "mm", "σ/μ"),
         source = rep("PaleoClim 1.0", 4),
         code = c("bio_6", "bio_12", "bio_13", "bio_15"),
         raster = as.list(raster::subset(bioclim,
                                         c("bio_6", "bio_12", "bio_13",
                                           "bio_15")))),
  tibble(group = rep("Soil", 5),
         time = rep(NA, 5),
         variable = c("Organic carbon content", "Coarse fragment content",
                      "Sand content", "Acidity", "Depth to bedrock"),
         units = c("g per kg fine earth", "% volume", "% mass", "pH ×10 in H2O",
                   "cm (up to 200 cm)"),
         source = rep("SoilGrids250m", 5),
         code = c("ORCDRC_M_sl2_250m", "CRFVOL_M_sl2_250m", "SNDPPT_M_sl2_250m",
                  "PHIHOX_M_sl2_250m", "BDRICM_M_250m"),
         raster = as.list(raster::subset(soilgrids,
                                         c("ORCDRC_M_sl2_250m", "CRFVOL_M_sl2_250m", "SNDPPT_M_sl2_250m",
                  "PHIHOX_M_sl2_250m", "BDRICM_M_250m")))),
  tibble(group = rep("Terrain", 3),
         time = rep(NA, 3),
         variable = c("Elevation", "Slope", "Topographic Wetness Index"),
         units = c("m", "°", "ln(upslope area / tan(slope))"),
         source = rep("SRTM DEM v3", 3),
         code = c("srtm1v3s_slevant", "srtm1v3s_slevant_slope",
                  "srtm1v3s_slevant_twi"),
         raster = as.list(terrain))
)

# PaleoClim
paleoclim %>% 
  transmute(group = "Climate", time = period_code, raster = raster) %>% 
  mutate(raster = map(raster, ~raster::unstack(.))) %>% 
  unnest() %>% 
  mutate(code = unlist(map(raster, names))) %>% 
  filter(code %in% c("bio_6", "bio_12", "bio_13", "bio_15")) %>% 
  {bind_rows(pred, .)} ->
  pred

pred %>%
  filter(time == "now" | is.na(time)) %>% 
  dplyr::select(-raster, -time) %>% 
  group_by(group) %>% 
  gt() %>% 
  cols_label(variable = "Variable", units = "Units", source = "Dataset",
             code = "Source code")
```

One aspect that we cannot easily incorporate into the models is the interaction between these taxa and other plant and animal species: cereal grasses grow best when they have no competition from perennial plants, *Fraxinus* often grows in scrub or forest, and so on.

We also lack data for soil salinity so far.

These datasets come with different resolutions.
To use them all in the same analysis, we resample them all to the finest dataset (the SRTM terrain variables, at 3 arc-second resolution).

```{r predictor-resample, include=FALSE}
# Parallelisation is Linux and Mac only.
# 
pred$raster <- mclapply(pred$raster, raster::resample, y = terrain, method = "ngb",
                        mc.cores = detectCores())
# pred$raster <- lapply(pred$raster, raster::resample, y = terrain, method = "ngb")
```

We will model the ecological niche of each species using a generalised linear regression.

First we extract the values of the predictor variables at each occurrence and pseudo-absence location:

```{r predictor-extraction, include=FALSE}
pred %>% 
  filter(time == "now" | is.na(time)) %>% 
  magrittr::extract2("raster") %>% 
  stack() %>% 
  raster::extract(as_Spatial(occ)) %>% 
  {cbind(occ, .)} %>% 
  st_as_sf(crs = st_crs(occ)) ->
  occ
```

### Species response curves

We can use species response curves to visualise the distribution of known occurrences in relation to these environmental gradients.
This will also help us parameterise the ecological niche models.

Species response curves are constructed with a simple logistic regression, fitting the probability of occurrence at a given location to 
The use of a linear regression assumes a unimodal response.
We fit first, second, and third order polynomial models to each species/predictor combination and calculate the Akaike Information Criterion (AIC).

```{r response-curves-fit, include=FALSE}
occ %>% 
  gather("pred_var", "pred_val", bio_6:twi) %>% 
  # NAs from gaps in the predictor data.
  drop_na(pred_val) %>%
  group_by(taxon, pred_var) %>% 
  nest() %>% 
  expand(taxon, pred_var, data, polyn = 1:3) %>%
  mutate(
    response_model = paste0("occurrence ~ poly(pred_val, ", polyn, ")"),
    response_fit = map2(data, response_model,
                        ~ glm(as.formula(.y),
                              family = "binomial",
                              data = .x,
                              weights = weight)),
    response_glance = map(response_fit, glance)
  ) ->
  response_models

# Select model with lowest AIC for each taxon–predictor combination
response_models %>%
  unnest(response_glance) %>% 
  group_by(taxon, pred_var) %>% 
  filter(AIC == min(AIC)) ->
  response_models
```

```{r response-curves-table, echo=FALSE}
# response_models %>% 
#   spread(polyn, aic) %>% 
#   rename(aic_poly1 = `1`, aic_poly2 = `2`, aic_poly3 = `3`) %>% 
#   gt(rowname_col = "predictor", groupname_col = "taxon") %>% 
#   tab_stubhead_label("predictor")
```

The optimal model is the one with the lowest AIC.

### Logistic regression

Now we can fit regression models combining all the predictor variables.

```{r model_fit, include=FALSE}
occ %>% 
  drop_na(bio_6:twi) %>% 
  group_by(taxon) %>% 
  nest() %>% 
  mutate(
    model = map_chr(taxon, ~ paste0(
      "occurrence ~ ",
      str_c(paste0("poly(",
                   filter(response_models, taxon == .x)$pred_var,
                   ", ",
                   filter(response_models, taxon == .x)$polyn,
                   ")"),
            collapse = " + "))),
    fit = map2(model, data,
               ~ glm(as.formula(.x),
                     family = "binomial",
                     data = .y,
                     weights = weight)),
    glance = map(fit, glance)
  ) ->
  enm
```


## Results
### Current conditions

We can now use the fitted models to predict the occurrence of the different taxa according to the predictor variables.
Initially, we do this based on current conditions.
This allows us to extrapolate from regions with good occurrence data (i.e. Israel/Palestine) to those without.
It also hints at what the distribution of the plant might be under "ideal conditions", without agriculture, grazing, etc.

```{r predictions, include=FALSE}
# Slow
profvis::profvis({
enm %>% 
  mutate(pred_now = map(fit, 
                        ~raster::predict(
                          raster::stack(
                            filter(pred, time == "now" | is.na(time))$raster),
                          .))) %>% 
  mutate(pred_eh = map(fit, 
                        ~raster::predict(
                          raster::stack(
                            filter(pred, time == "eh" | is.na(time))$raster),
                          .))) %>% 
  mutate(pred_yds = map(fit, 
                         ~raster::predict(
                           raster::stack(
                             filter(pred, time == "yds" | is.na(time))$raster),
                           .))) %>% 
  mutate(pred_ba = map(fit, 
                        ~raster::predict(
                          raster::stack(
                            filter(pred, time == "ba" | is.na(time))$raster),
                          .))) %>% 
  mutate(pred_hs1 = map(fit, 
                         ~raster::predict(
                           raster::stack(
                             filter(pred, time == "hs1" | is.na(time))$raster),
                           .))) %>% 
  mutate(pred_lgm = map(fit, 
                         ~raster::predict(
                           raster::stack(
                             filter(pred, time == "lgm" | is.na(time))$raster),
                           .))) %>% 
  mutate(pred_now = map(pred_now, logit_to_p),
         pred_eh = map(pred_eh, logit_to_p),
         pred_yds = map(pred_yds, logit_to_p),
         pred_ba = map(pred_ba, logit_to_p),
         pred_hs1 = map(pred_hs1, logit_to_p),
         pred_lgm = map(pred_yds, logit_to_p)) ->
  enm
})
```

```{r pred_current_plot, echo=FALSE}
raster::stack(enm$pred_now) %>%
  set_names(enm$taxon) %>% 
  plot()
```

```{r pred_yds_}

## Discussion
