---
title: "Palaeodistribution of crop progenitors and wild foods in the Southern Levant"
author: "Joe Roe"
format: html
bibliography: references.bib
---

```{r dependencies}
library("dplyr")
library("fs")
library("furrr")
library("ggplot2")
library("ggspatial")
library("gt")
library("here")
library("parsnip")
library("purrr")
library("ranger")
library("readr")
library("rgbif")
library("rpaleoclim")
library("sf")
library("stars")
library("stringr")
library("tibble")
library("tidyr")

library("BadiaPaleoFloraENM") # this package, install with devtools::install()
```

```{r setup-parallel}
# Several parts of this analysis are processing- and memory-intensive.
# You may need to adjust the futures strategy specified here to fit your 
# computational resources. See ?future::plan for options.
plan("multisession")
```

```{r define-regions}
latlong <- 4326
utm37n <- 32637

w_asia <- st_bbox(c(xmin = 30, xmax = 50, ymin = 25, ymax = 40), crs = 4326)
s_levant <- st_bbox(c(xmin = 34, xmax = 39, ymin = 29, ymax = 34), crs = 4326)
```

```{r define-periods}
archaeo_periods <- tribble(
  ~period,             ~agriculture,                          ~start_bp, ~end_bp,
  "Late Epipal.",      "Foraging",                            15000,     11700,
  "PPNA",              "Pre-domestication cultivation",       11700,     10700,
  "EPPNB",             "Cultivation of domesticated species", 10700,     10200,
  "MPPNB",             "Cultivation of domesticated species", 10200,     9500,
  "LPPNB/C",           "Agriculture",                         9500,      8500,
  "Pottery Neolithic", "Agriculture",                         8500,      6500,
  "Chalcolithic",      "Agriculture",                         6500,      5000,
)

neolithic <- c("PPNA", "EPPNB", "MPPNB", "LPPNB/C", "Pottery Neolithic")
```

## Introduction

## Background

## Methods and materials

```{r read-basemap}
# Turn off s2 while we deal with Natural Earth's dodgy geometries
use_s2 <- sf_use_s2(FALSE)

ne_countries <- read_sf(raw_data("ne"), "ne_10m_admin_0_countries")

ne_lakes <- read_sf(raw_data("ne"), "ne_10m_lakes") |> 
  st_geometry() |>
  st_crop(buffer_bbox(w_asia, 10)) |>
  st_union()

ne_ocean <- read_sf(raw_data("ne"), "ne_10m_ocean") |>
  st_geometry() |>
  st_crop(buffer_bbox(w_asia, 10)) |>
  st_union()

ne_land <- read_sf(raw_data("ne"), "ne_10m_land") |> 
  st_geometry() |>
  st_crop(buffer_bbox(w_asia, 10)) |>
  st_difference(ne_ocean) |>
  st_difference(ne_lakes) |>
  st_union()

s_levant_land <- st_intersection(st_as_sfc(s_levant), ne_land)
w_asia_land <- st_intersection(st_as_sfc(w_asia), ne_land)

# Restore previous setting of s2
sf_use_s2(use_s2)
```

### Occurrence data

```{r read-archaeo_flora}
archae_flora <- read_tsv(raw_data("swasia_neolithic_flora.tsv"))
```

```{r tidy-archaeo_flora}
archaeo_flora |>
  rename(taxon_group = "taxon", taxon = "taxon_detail") |>
  # Assign to archaeological periods
  # TODO: refactor as function
  # TODO: assign climate periods too
  mutate(
    age_mid = age_end + ((age_start - age_end) / 2),
    period = cut(-age_mid, 
                 breaks = -c(archaeo_periods$start_bp, 0), 
                 labels = archaeo_periods$period,
                 ordered_result = TRUE)
  ) ->
  archaeo_flora
```

```{r summarise-archaeo_flora}
n_assemb_neolithic <- archaeo_flora |> 
  distinct(site_name, phase_code, period) |> 
  filter(period %in% neolithic) |> 
  nrow()

n_site_neolithic <- archaeo_flora |> 
  filter(period %in% neolithic) |> 
  distinct(site_name) |> 
  nrow()
```

To generate the list of taxa modelled in this study, we ...

* Taxa present at more than three Neolithic sites, according to the database of our previous study [@ArranzOtaeguiRoe2023]
* Identified at least to species (and matchable to the GBIF Backbone Taxonomy)
* Have at least 100 occurrences in West Asia (meeting the criteria below) in the GBIF database
* Excluded domestic species, replacing them with their wild progenitor, where known and present in the GBIF database

We also considered the number modern occurrences available for each taxon.
ENMs are known to have reasonable predictive power even with small training samples (i.e. less than a hundred observations, [@StockwellPeterson2002; @HernandezEtAl2006; @WiszEtAl2008]).

```{r generate-flora}
archaeo_flora |>
  filter(period %in% neolithic) |>
  group_by(taxon) |>
  summarise(
    n_present = length(unique(phase_code)),
    p_present = n_present / n_assemb_neolithic,
    .groups = "drop"
  ) |>
  filter(n_present > 2) ->
  flora
```

```{r tidy-flora-taxonomy}
# Normalise species names and match to the GBIF Backbone Taxonomy
# Excluding taxa not identified to species
flora |>
  filter(!str_ends(taxon, "sp.")) |>
  mutate(
    taxon = case_match(taxon,
                       "Vicia narbonense" ~ "Vicia narbonensis", # N=3
                       "Triticum aestivocompactum" ~ "Triticum aestivum compactum", # N=3
                       "Heliotropium persicum" ~ "Moltkia angustifolia", # N=2
                       "Lens orientalis" ~ "Vicia orientalis", # N=2
                       "Scirpus tabernaemontani" ~ "Schoenoplectus tabernaemontani", # N=2
                       "Stipa capensis" ~ "Stipa dregeana", # N=2
                       .default = taxon),
    taxon_original = taxon,
    taxon = map_chr(taxon, gbif_accepted_name)
  ) ->
  flora
```

```{r tidy-flora-domesticates}
# Recode domesticates as their wild progenitors.
# Add other wild progenitors of wheats
flora |> 
  mutate(taxon = case_match(
    taxon,
    "Cicer arietinum" ~ "Cicer reticulatum",
    "Hordeum vulgare" ~ "Hordeum spontaneum",
    "Vicia lens" ~ "Vicia orientalis",
    "Linum usitatissimum" ~ "Linum bienne",
    "Triticum aestivum" ~ "Triticum turgidum dicoccum",
    "Triticum dicoccoides" ~ "Triticum turgidum dicoccum",
    "Triticum turgidum durum" ~ "Triticum turgidum dicoccum",
    "Triticum monococcum" ~ "Triticum monococcum aegilopoides",
    .default = taxon
  )) |>
  bind_rows(tibble(taxon = c("Triticum urartu", "Aegilops speltoides", 
                             "Aegilops tauschii"))) ->
  flora
```

```{r fetch-occ-count}
flora |>
  group_by(taxon) |>
  summarise(
    taxon_original = list(c(taxon_original)),
    n_present = max(n_present), # TODO: be more precise?
    p_present = max(p_present)
    ) |>
  mutate(n_occ = map_dbl(taxon, \(x) occ_count(scientificName = x, 
                                               hasCoordinate = TRUE, 
                                               hasGeospatialIssue = FALSE,
                                               geometry = bbox_wkt(w_asia)))) ->
  flora
```

```{r tbl-occ-count}
#| tbl-cap: "Species modelled in this study."
# TODO: add to caption:
# - with presence in Neolithic sites in West Asia, out of the X sites included in Y
# - with number of reliably-georeferenced occurrences in West Asia recorded in GBIF
# TODO: add count of species included?
flora |>
  mutate(
    taxon_detail = map_chr(taxon_original, paste, collapse = ", "),
    taxon_detail = if_else(taxon == taxon_detail, NA_character_, taxon_detail),
    include = n_occ > 50
  ) |>
  select(-taxon_original) |>
  group_by(include) |>
  arrange(-n_present) |>
  gt() |>
  cols_merge(
    c(taxon, taxon_detail),
    rows = !is.na(taxon_detail),
    pattern = "{1}<br><small>(incl. {2})</small>"
  ) |>
  fmt_percent(p_present, decimals = 0) |>
  cols_merge_n_pct(n_present, p_present) |>
  tab_style(cell_text(style = "italic"), cells_body(taxon))
```

```{r filter-flora}
flora <- filter(flora, n_occ > 50)
```

Occurrence data was obtained from GBIF using the GBIF occurrence API.
This deals with synonyms etc. (using the GBIF Backbone Taxonomy as a standard), so e.g. retrieving data for "Bolboschoenus" includes all species and subspecies, including specimens described as *Bolboschoenus sp.*, *Bolboschoenus maritimus* and *Scirpus maritimus*.

```{r fetch-occ}
# TODO: Refactor
gbif_data <- function(scientificName, ...) {
  gbif_data <- rgbif::occ_data(scientificName = scientificName, ...)
  gbif_data$data
}

flora |>
  mutate(
    occ = future_map(taxon, gbif_data, 
                     hasCoordinate = TRUE, hasGeospatialIssue = FALSE, 
                     geometry = w_asia, limit = 100000)
  ) ->
  flora
```

```{r tidy-occ}
# TODO: further tidying. Ideas:
# - https://data-blog.gbif.org/post/gbif-filtering-guide/
# - https://cran.r-project.org/web/packages/CoordinateCleaner/vignettes/Cleaning_GBIF_data_with_CoordinateCleaner.html
# - https://www.r-bloggers.com/2021/03/downloading-and-cleaning-gbif-data-with-r/
flora |>
  mutate(
    occ = future_map(occ, gbif_drop_imprecise_coords, threshold = 5000),
    occ = future_map(occ, gbif_drop_fossils),
    occ = future_map(occ, gbif_drop_duplicate_coords),
    occ = future_map(occ, gbif_standardise_names),
    occ = future_map(occ, \(x) {
      select(x, gbif_key = key, scientific_name, genus, species, longitude, 
             latitude)
    })
  ) ->
  flora
```

```{r fig-occ-map}
flora |>
  unnest(occ) |>
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) |>
  ggplot() + 
  facet_wrap(vars(taxon)) +
  layer_spatial(ne_land, fill = "#ffffff") +
  geom_sf(shape = ".") +
  coord_sf(xlim = w_asia[c("xmin", "xmax")], 
           ylim = w_asia[c("ymin", "ymax")],
           crs = utm37n,
           default_crs = latlong)
```

<!-- TODO: following @ValaviEtAl2022, more accurate to call pseudo-absences
  "background samples" -->
Occurrence data only tells us where a species is present;
there is no definitive information on where the species is *not* found.
We therefore need to generate random background points or "pseudo-absences" to feed to the model.
There are several ways to do this. 
We follow the advice of Barbet-Massin et al. (2012) for regression-based species distribution models and use a large (~10000) random sample of points, weighted equally against the presences in the regression.
@ValaviEtAl2022 recommends using a very large background sample for random forest models.

```{r generate-background}
# TODO: Refactor to work with nested occ
# TODO: maybe defer this to just before the model is actually fit 
#   (and discard the background sample)
n_background <- 10000

occ |>
  mutate(present = TRUE) |>
  group_by(taxon) |>
  nest(.key = "occ_data") |>
  mutate(bg_data = map(1:n(), \(i) { 
    background_sample(
      region = w_asia_land, 
      N = n_background,
      coord_x = "longitude", coord_y = "latitude",
      present = FALSE
    )
  })) |>
  mutate(data = map2(occ_data, bg_data, bind_rows)) |>
  select(taxon, data) |>
  unnest(data) |>
  st_sf() ->
  occ
```

### Predictor data

```{r data-climate}
raw_data("paleoclim") |>
  dir_ls() |>
  map(dir_ls, glob = "*.tif") |>
  map(read_stars) |>
  map(\(x) set_names(x, path_ext_remove(path_file(names(x))))) ->
  climate

# Tidy up names
names(climate) |>
  basename() |>
  str_remove(regex("chelsa_", ignore_case = TRUE)) |>
  str_split_i("_", 1) ->
  names(climate)
```

```{r training-climate}
occ <- cbind(occ, st_extract(climate$cur, occ)) |> select(-geometry.1)
```

TODO: Soil, terrain (incl. TWI, slope?)

### Random Forest

There are many methods for ENM.
Random Forest is one of the best performing, providing it is appropriately parameterised to account for the class imbalance between presence and background samples (balanced random forest) [@ValaviEtAl2021a; @ValaviEtAl2021b].

We used the R package ranger [@WrightZiegler2017].

```{r model}
rf_predictors <- function() {
  c(any_of("present"), starts_with("bio"))
}

# Drop any rows with NA values in any of the predictor variables
# TODO: Where do these actually come from? There's usually only a handful.
occ <- drop_na(occ, rf_predictors())

# Model
# Parameters adapted from the example of a down-sampled RF model given in
#   https://rvalavi.github.io/SDMwithRFs/#model-fitting-with-ranger-package
# TODO: tune?

rf_model <- rand_forest(mode = "classification", trees = 1000) |>
  set_engine(
    "ranger",
    probability = TRUE,
    sample.fraction = c(sum(as.logical(.y())) / n_background, 1)
  )

# Fit to each taxon
# TODO: parallelise
occ |>
  nest(.by = taxon) |>
  mutate(
    data = map(data, as_tibble),
    fit = map(data, \(data) {
      fit(rf_model, factor(present) ~ ., data = select(data, rf_pred_vars()))
    })) ->
  rf_fits

# TODO: not this
rf_fits$taxon <- taxa$taxon
```

The output of the model is probalistic.
However, this should not be understood as an actual probability of occurrence [@CITE], but more akin to habitat suitability.
To simplify interpretation, we can convert these predictions into binary presence/absence maps, a process called "thresholding".
We select the threshold value for each model individually, using MaxSSS (as recommended by [@LuiEtAl2013])
This also makes it possible to analyses the predictions together as an assemblage.

```{r thresholding}
# TODO: thresholding
# - Pick a threshold
# - Reclassify pred raster
# - Extract predicted classification (for cur) for occ
# - ...or predict back onto the occurrence data? do we actually need the rasters for this?
# - Calculate sensitivity and with yardstick
# - Sum (SSS)
# - (Plot?)
# - Pick max SSS
```

## Results

### Modelled ecological niches

* On current data
* Sensitivity to climate fluctuations

### Hindcasting

```{r predict}
# TODO: tidy
rf_fit <- filter(rf_fits, taxon == "Triticum urartu") |>
  pull(fit)
rf_fit <- rf_fit[[1]]

# TODO: Maybe combine stars and collapse period into dimension first?
rf_pred <- map(climate, predict, model = rf_fit, type = "prob")
rf_pred <- map(rf_pred, \(x) x[".pred_TRUE"])
rf_pred <- do.call(c, rf_pred)
rf_pred <- st_redimension(rf_pred, name = "period")

ggplot() + 
  geom_stars(data = st_crop(rf_pred, w_asia)) + 
  facet_wrap(~period) +
  scale_fill_batlow(reverse = TRUE)
```

### Model assessment & verification

```{r todo}
# TODO: model performance assessment:
# - R2
# - Boyce index
# - AUC, ROC, AUC-ROC, AUC-PRG ?
# - TSS

```

## Discussion
