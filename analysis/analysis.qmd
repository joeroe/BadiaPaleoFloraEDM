---
title: Biogeography of crop progenitors and wild plant resources during the transition to agriculture in West Asia
date: today
author: 
- name: Joe Roe
  id: jr
  orcid: 0000-0002-1011-1244
  email: joeroe@hey.com
  affiliation: University of Bern
- name: Amaia Arranz-Otaegui
  id: aao
  orcid: 0000-0002-5091-6426
  affiliation: University of the Basque Country
abstract: |
  This paper presents the first comprehensive reconstructions of the prehistoric 
  ranges of [X] plant species known to have been gathered or cultivated by early
  agricultural societies in Southwest Asia, including the progenitors of the 
  first crops. We used machine learning to train an ecological niche model (ENM)
  of each species based on its present-day distribution in relation to climate 
  and environmental variables. Predictions of the potential ranges of these 
  species at key stages of the Pleistocene–Holocene transition could then be
  derived from these models using palaeoclimate 
  Species ranges were on average [X%] [larger|smaller] in the Early Holocene 
  compared to today, indicating [...]. The modelled ranges predict the
  observed occurrence of these species on archaeological sites with [low|medium|high]
  accuracy. The regional ubiquity of species in the archaeological record is [not] 
  correlated with the predicted size of its range and the diversity of
  archaeobotanical assemblages is [not] correlated with the predicted diversity
  of its environs. This indicates that trends in taxonomic composition of
  the archaeobotanical record is [not] likely to be influenced by environmental 
  change and species turnover, not just, as is often assumed, human economic 
  choices.
format: html
bibliography: references.bib
---

```{r dependencies}
library("cowplot")
library("dplyr")
library("forcats")
library("fs")
library("furrr")
library("ggplot2")
library("ggrepel")
library("ggspatial")
library("gt")
library("here")
library("khroma")
library("progressr")
library("purrr")
library("ranger")
library("readr")
library("recipes")
library("rgbif")
library("rpaleoclim")
library("scales")
library("sf")
library("stars")
library("stringr")
library("tibble")
library("tidymodels")
library("tidyr")

library("BadiaPaleoFloraENM") # this package, install with devtools::install()
```

```{r setup-parallel}
# Several parts of this analysis are processing- and memory-intensive.
# You may need to adjust the futures strategy specified here to fit your 
# computational resources. See ?future::plan for options.
plan("multisession")
```

```{r define-regions}
latlong <- 4326
utm37n <- 32637

w_asia <- st_bbox(c(xmin = 30, xmax = 50, ymin = 25, ymax = 40), crs = 4326)
s_levant <- st_bbox(c(xmin = 34, xmax = 39, ymin = 29, ymax = 34), crs = 4326)
```

```{r define-periods}
archaeo_periods <- tribble(
  ~period,             ~agriculture,                          ~start_bp, ~end_bp,
  "Late Epipal.",      "Foraging",                            15000,     11700,
  "PPNA",              "Pre-domestication cultivation",       11700,     10700,
  "EPPNB",             "Cultivation of domesticated species", 10700,     10200,
  "MPPNB",             "Cultivation of domesticated species", 10200,     9500,
  "LPPNB/C",           "Agriculture",                         9500,      8500,
  "Pottery Neolithic", "Agriculture",                         8500,      6500,
  "Chalcolithic",      "Agriculture",                         6500,      5000,
)

neolithic <- c("PPNA", "EPPNB", "MPPNB", "LPPNB/C", "Pottery Neolithic")
```

## Introduction

* The first farming societies had an ecological context
* Subsistence is understood (largely) through archaeobotany; ecological context from archaeobotany, palynology, palaeoclimate, etc.
  * But these have a variety of biases (human selection, taphonomy, etc.)
  * And at the end of the day only represent specific places – interpolation to the entire region is not straightforward
  * Overlap makes it difficult to see where human choices depart from the environmental background [cf. Martin et al. 2016, for zooarch]
* Here we present an alternative approach using ENM
  * Whole region, at multiple climate snapshots
  * Independent of archaeobot. and pal. clim. data, so can verify and compare

## Background

* Epipal./Neo. plant-based economies
  * More than the "founder crops"; 
  * More than food;
  * Regionally and temporally diverse
  * ...so we model lots of species!
* Regional ecological reconstructions
  * See CSEAS (AEA-prep) presentation
  * Figure: comparisons
* Archaeological applications of ENM
  * Review: Franklin et al. 2015
  * In SW Asia: Conolly et al. 2012, Collins et al. 2018
  * Train with archaeo, or train with present-day?
    * In ENM literature, many sceptical about fore- and hind-casting
    * Archaeo data a golden opportunity here

## Methods and materials

```{r read-basemap}
# Turn off s2 while we deal with Natural Earth's dodgy geometries
use_s2 <- sf_use_s2(FALSE)

ne_countries <- read_sf(raw_data("ne"), "ne_10m_admin_0_countries")

ne_lakes <- read_sf(raw_data("ne"), "ne_10m_lakes") |> 
  st_geometry() |>
  st_crop(buffer_bbox(w_asia, 10)) |>
  st_union()

ne_ocean <- read_sf(raw_data("ne"), "ne_10m_ocean") |>
  st_geometry() |>
  st_crop(buffer_bbox(w_asia, 10)) |>
  st_union()

ne_land <- read_sf(raw_data("ne"), "ne_10m_land") |> 
  st_geometry() |>
  st_crop(buffer_bbox(w_asia, 10)) |>
  st_difference(ne_ocean) |>
  st_difference(ne_lakes) |>
  st_union()

s_levant_land <- st_intersection(st_as_sfc(s_levant), ne_land)
w_asia_land <- st_intersection(st_as_sfc(w_asia), ne_land)

# Restore previous setting of s2
sf_use_s2(use_s2)
```

### Occurrence data

```{r read-archaeo_flora}
archaeo_flora <- read_tsv(raw_data("swasia_neolithic_flora.tsv"))
```

```{r tidy-archaeo_flora}
archaeo_flora |>
  rename(taxon_group = "taxon", taxon = "taxon_detail") |>
  # Assign to archaeological periods
  # TODO: refactor as function
  # TODO: assign climate periods too
  mutate(
    age_mid = age_end + ((age_start - age_end) / 2),
    period = cut(-age_mid, 
                 breaks = -c(archaeo_periods$start_bp, 0), 
                 labels = archaeo_periods$period,
                 ordered_result = TRUE)
  ) ->
  archaeo_flora
```

```{r summarise-archaeo_flora}
n_assemb_neolithic <- archaeo_flora |> 
  distinct(site_name, phase_code, period) |> 
  filter(period %in% neolithic) |> 
  nrow()

n_site_neolithic <- archaeo_flora |> 
  filter(period %in% neolithic) |> 
  distinct(site_name) |> 
  nrow()
```

To generate the list of taxa modelled in this study, we ...

* Taxa present at more than three Neolithic sites, according to the database of our previous study [@ArranzOtaeguiRoe2023]
* Identified at least to species (and matchable to the GBIF Backbone Taxonomy)
* Have at least 100 occurrences in West Asia (meeting the criteria below) in the GBIF database
* Excluded domestic species, replacing them with their wild progenitor, where known and present in the GBIF database

We also considered the number modern occurrences available for each taxon.
ENMs are known to have reasonable predictive power even with small training samples (i.e. less than a hundred observations, [@StockwellPeterson2002; @HernandezEtAl2006; @WiszEtAl2008]).

```{r generate-flora}
archaeo_flora |>
  filter(period %in% neolithic) |>
  group_by(taxon) |>
  summarise(
    n_present = length(unique(phase_code)),
    p_present = n_present / n_assemb_neolithic,
    .groups = "drop"
  ) |>
  filter(n_present > 2) ->
  flora
```

```{r tidy-flora-taxonomy}
# Normalise species names and match to the GBIF Backbone Taxonomy
# Excluding taxa not identified to species
flora |>
  filter(!str_ends(taxon, "sp.")) |>
  mutate(
    taxon = case_match(taxon,
                       "Vicia narbonense" ~ "Vicia narbonensis", # N=3
                       "Triticum aestivocompactum" ~ "Triticum aestivum compactum", # N=3
                       "Heliotropium persicum" ~ "Moltkia angustifolia", # N=2
                       "Lens orientalis" ~ "Vicia orientalis", # N=2
                       "Scirpus tabernaemontani" ~ "Schoenoplectus tabernaemontani", # N=2
                       "Stipa capensis" ~ "Stipa dregeana", # N=2
                       .default = taxon),
    taxon_original = taxon,
    taxon = map_chr(taxon, gbif_accepted_name)
  ) ->
  flora
```

```{r tidy-flora-domesticates}
# Recode domesticates as their wild progenitors.
# Add other wild progenitors of wheats
flora |> 
  mutate(taxon = case_match(
    taxon,
    "Cicer arietinum" ~ "Cicer reticulatum",
    "Hordeum vulgare" ~ "Hordeum spontaneum",
    "Vicia lens" ~ "Vicia orientalis",
    "Linum usitatissimum" ~ "Linum bienne",
    "Triticum aestivum" ~ "Triticum turgidum dicoccum",
    "Triticum dicoccoides" ~ "Triticum turgidum dicoccum",
    "Triticum turgidum durum" ~ "Triticum turgidum dicoccum",
    "Triticum monococcum" ~ "Triticum monococcum aegilopoides",
    .default = taxon
  )) |>
  bind_rows(tibble(taxon = c("Triticum urartu", "Aegilops speltoides", 
                             "Aegilops tauschii"))) ->
  flora
```

```{r fetch-occ-count}
flora |>
  group_by(taxon) |>
  summarise(
    taxon_original = list(c(taxon_original)),
    n_present = max(n_present), # TODO: be more precise?
    p_present = max(p_present)
    ) |>
  mutate(n_occ = map_dbl(taxon, \(x) occ_count(scientificName = x, 
                                               hasCoordinate = TRUE, 
                                               hasGeospatialIssue = FALSE,
                                               geometry = bbox_wkt(w_asia)))) ->
  flora
```

```{r tbl-occ-count}
#| tbl-cap: "Species modelled in this study."
# TODO: add to caption:
# - with presence in Neolithic sites in West Asia, out of the X sites included in Y
# - with number of reliably-georeferenced occurrences in West Asia recorded in GBIF
# TODO: add count of species included?
flora |>
  mutate(
    taxon_detail = map_chr(taxon_original, paste, collapse = ", "),
    taxon_detail = if_else(taxon == taxon_detail, NA_character_, taxon_detail),
    #include = n_occ > 50
  ) |>
  select(-taxon_original) |>
  # group_by(include) |>
  filter(n_occ > 50) |>
  arrange(-n_present) |>
  gt() |>
  # TODO: move synonyms to footnotes?
  cols_merge(
    c(taxon, taxon_detail),
    rows = !is.na(taxon_detail),
    pattern = "{1}<br><small>(incl. {2})</small>"
  ) |>
  fmt_percent(p_present, decimals = 0) |>
  cols_merge_n_pct(n_present, p_present) |>
  tab_style(cell_text(style = "italic"), cells_body(taxon))
```

```{r filter-flora}
flora <- filter(flora, n_occ > 50)
# TODO: Temporary measure.
# Why are there 47k occurrences of Avena sterilis??
flora <- filter(flora, taxon != "Avena sterilis")
```

Occurrence data was obtained from GBIF using the GBIF occurrence API.
This deals with synonyms etc. (using the GBIF Backbone Taxonomy as a standard), so e.g. retrieving data for "Bolboschoenus" includes all species and subspecies, including specimens described as *Bolboschoenus sp.*, *Bolboschoenus maritimus* and *Scirpus maritimus*.

```{r fetch-occ}
# TODO: Refactor
gbif_data <- function(scientificName, ...) {
  gbif_data <- rgbif::occ_data(scientificName = scientificName, ...)
  gbif_data$data
}

flora |>
  mutate(
    occ = map(taxon, gbif_data, 
              hasCoordinate = TRUE, hasGeospatialIssue = FALSE, 
              geometry = w_asia, limit = 100000,
              .progress = TRUE)
  ) ->
  flora
```

```{r tidy-occ}
# TODO: further tidying. Ideas:
# - https://data-blog.gbif.org/post/gbif-filtering-guide/
# - https://cran.r-project.org/web/packages/CoordinateCleaner/vignettes/Cleaning_GBIF_data_with_CoordinateCleaner.html
# - https://www.r-bloggers.com/2021/03/downloading-and-cleaning-gbif-data-with-r/
flora |>
  mutate(
    occ = map(occ, gbif_drop_imprecise_coords, threshold = 5000),
    occ = map(occ, gbif_drop_fossils),
    occ = map(occ, gbif_drop_duplicate_coords),
    occ = map(occ, gbif_standardise_names),
    occ = map(occ, \(x) {
      select(x, gbif_key = key, scientific_name, genus, species, longitude, 
             latitude)
    })
  ) ->
  flora
```

```{r fig-occ-map}
flora |>
  unnest(occ) |>
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) |>
  ggplot() + 
  facet_wrap(vars(taxon)) +
  layer_spatial(ne_land, fill = "#ffffff") +
  geom_sf(shape = ".") +
  coord_sf(xlim = w_asia[c("xmin", "xmax")], 
           ylim = w_asia[c("ymin", "ymax")],
           crs = utm37n,
           default_crs = latlong)
```

<!-- TODO: following @ValaviEtAl2022, more accurate to call pseudo-absences
  "background samples" -->
Occurrence data only tells us where a species is present;
there is no definitive information on where the species is *not* found.
We therefore need to generate random background points or "pseudo-absences" to feed to the model.
There are several ways to do this. 
We follow the advice of Barbet-Massin et al. (2012) for regression-based species distribution models and use a large (~10000) random sample of points, weighted equally against the presences in the regression.
@ValaviEtAl2022 recommends using a very large background sample for random forest models.

```{r generate-background}
# TODO: maybe defer this to just before the model is actually fit ?
#   (and discard the background sample)
# using a custom recipe step even?
n_background <- 10000

flora <- flora |>
  mutate(
    occ = map(occ, mutate, present = TRUE, weight = 1),
    bg_data = map(occ, function(x, region, n) { 
      background_sample(
        region = region, 
        N = n,
        coord_x = "longitude", coord_y = "latitude",
        present = FALSE,
        weight = (1 / n) * nrow(x) # weight presences and background equally
      )
    }, region = w_asia_land, n = n_background),
    occ = map2(occ, bg_data, bind_rows)
  ) |>
  select(-bg_data)
```

### Predictor data

```{r data-climate}
raw_data("paleoclim") |>
  dir_ls() |>
  map(dir_ls, glob = "*.tif") |>
  map(read_stars) |>
  map(\(x) set_names(x, path_ext_remove(path_file(names(x))))) ->
  climate

# Tidy up names
names(climate) |>
  basename() |>
  str_remove(regex("chelsa_", ignore_case = TRUE)) |>
  str_split_i("_", 1) ->
  names(climate)
```

```{r training-climate}
flora |> 
  mutate(
    occ = map(occ, \(x) cbind(x, st_extract(climate$cur, gbif_to_sf(x)))),
    # TODO: where is the extra geometry column coming from?
    occ = map(occ, \(x) as_tibble(select(x, -geometry))),
    # TODO: can this happen earlier?
    occ = map(occ, \(x) mutate(x, present = factor(present, c(FALSE, TRUE))))
  ) ->
  flora
```

TODO: Soil, terrain (incl. TWI, slope?)

### Random Forest

There are many methods for ENM.
Random Forest is one of the best performing, providing it is appropriately parameterised to account for the class imbalance between presence and background samples (balanced random forest) [@ValaviEtAl2021a; @ValaviEtAl2021b].

We used the R package ranger [@WrightZiegler2017].

```{r prepare-niche-model-data}
# Split training, test (for model assessment) and cross-validation sets (for
# tuning)
flora <- flora |>
  mutate(
    occ = map(occ, \(x) mutate(x, weight = importance_weights(weight))),
    occ = map(occ, \(x) drop_na(x, starts_with("bio"))), # TODO: where do these come from?
    occ_split = map(occ, \(x) initial_split(x, strata = present)),
    # occ_folds = map(occ_split, \(x) vfold_cv(training(x), v = 10, strata = present))
  )

# Data preprocessing recipe
# Following recommended preprocessing steps for RF classification from:
#   https://www.tmwr.org/pre-proc-table.html
niche_recipe <- recipe(training(flora$occ_split[[1]])) |>
  update_role(gbif_key:latitude, new_role = "ID") |>
  update_role(present, new_role = "outcome") |>
  update_role(starts_with("bio"), new_role = "predictor") |>
  step_nzv(all_predictors())
```

```{r niche-models}
# Random Forest Niche Model
# With hyperparameters adapted from the example of a down-sampled RF model given 
# by https://rvalavi.github.io/SDMwithRFs/#model-fitting-with-ranger-package
niche_model <- rand_forest(mode = "classification", trees = 1000) |>
  set_engine(
    "ranger", 
    sample.fraction = c(sum(as.logical(.y())) / n_background, 1),
    probability = TRUE
  )

# TODO: Or... tune parameters? But this is very compute-intensive.
# niche_model <- rand_forest(
#   mode = "classification", 
#   mtry = tune(),
#   trees = tune(),
#   min_n = tune()
# ) |>
#   set_engine("ranger", probability = TRUE)

niche_workflow <- workflow(niche_recipe, niche_model)
```

We follow @ValaviEtAl2021a in using down-sampling and their recommended hyperparameters to avoid overfitting.

<!-- TODO: OR:
Hyperparameter tuning is important to avoid over-fitting [@CITE].
We tuned each model separately to maximise ROC AUC.
-->

```{r tune-niche-models}
# Tune model (separately for each taxon)
# TODO: would be nice but is extremely slow
# flora |>
#   slice_sample(n = 10) |>
#   mutate(
#     niche_tuning_grid = map(occ_split, function(data, recipe) {
#       grid_regular(
#         finalize(mtry(), bake(prep(recipe), training(data), all_predictors())),
#         trees(),
#         min_n(),
#         levels = 5
#       )
#     }, recipe = niche_recipe, .progress = TRUE),
#     niche_tuning = map2(niche_tuning_grid, occ_folds, function(grid, folds, wflow) {
#       tune_grid(wflow, folds, grid = grid)
#     }, wflow = niche_workflow, .progress = TRUE),
#     niche_hparams = map(niche_tuning, select_best, metric = "roc_auc"),
#     niche_model = map(niche_hparams, function(params, wflow) {
#       finalize_workflow(wflow, params)
#     }, wflow = niche_workflow)
#   )
```

```{r fit-niche-models}
# Fit best model to training data
flora <- flora |>
  mutate(
    niche = map(occ_split, \(x) last_fit(niche_workflow, x), .progress = TRUE)
  )
```

The output of the model is probabilistic.
However, this should not be understood as an actual probability of occurrence [@CITE], but more akin to an estimate of habitat suitability.
To simplify interpretation, we can convert these predictions into binary presence/absence maps, a process called "thresholding".
We select the threshold value for each model individually, using MaxSSS (as recommended by [@LuiEtAl2013])
This also makes it possible to analyses the predictions together as an assemblage.

```{r thresholding}
# TODO: thresholding?
# - Pick a threshold
# - Reclassify pred raster
# - Extract predicted classification (for cur) for occ
# - ...or predict back onto the occurrence data? do we actually need the rasters for this?
# - Calculate sensitivity and with yardstick
# - Sum (SSS)
# - (Plot?)
# - Pick max SSS
#
# Or just stick with probabilities?
```

## Results

### Model assessment

```{r niche_model_test}
# Predict model on test data and assess performance
# TODO: model performance assessments:
# - [ ] R2
# - [ ] Boyce index
# - [x] AUC, ROC, AUC-ROC, AUC-PRG ?
# - [ ] TSS
# flora <- flora |>
#   mutate(
#     niche_test = map2(niche, occ_split, \(x, y) augment(x, testing(y))),
#     niche_test_roc_auc = map_dbl(niche_test, function(x) {
#       roc_auc(x, present, .pred_TRUE)$.estimate
#     }),
#     niche_test_accuracy = map_dbl(niche_test, function(x) {
#       accuracy(x, present, .pred_class)$.estimate
#     })
#   )

# TODO: filter to minimum accuracy? 0.85? 0.9? 0.95?
```

```{r fig-model-accuracy-vs-n_occ}
#| fig-cap: Number of taxon occurrences and model accuracy on test dataset
flora |>
  mutate(niche_test_fit = map(niche, collect_metrics)) |>
  unnest(niche_test_fit) |>
  filter(.metric == "accuracy") |> # TODO: or roc_auc?
  mutate(label = if_else(.estimate < 0.8, taxon, NA_character_)) |>
  ggplot(aes(n_occ, .estimate)) + 
  geom_smooth(method = "glm", formula = y ~ log(x)) +
  geom_point() + 
  geom_text_repel(aes(label = label), fontface = "italic") +
  scale_x_log10(name = "Occurrences") +
  scale_y_continuous(name = "Model accuracy", labels = label_percent()) +
  theme_half_open() 
```

### Modelled ecological niches

* On current data
* Sensitivity to climate fluctuations

### Hindcasting

```{r predict}
# TODO: structure this way from the beginning?
# Thanks to https://stackoverflow.com/questions/65183306/stars-package-how-to-define-additional-dimensions-based-on-an-attribute-filena
climate_pred <- do.call(c, map(climate, st_redimension, name = "variable")) |>
  st_redimension(name = "period") |>
  split("variable")

# TODO: very high memory usage
flora <- flora |>
  mutate(
    prediction = map(niche, \(mod, obj) predict(obj, extract_fit_engine(mod)), 
                     obj = climate_pred)
  )
```

```{r fig-niche-prediction}
niche_prediction <- filter(flora, taxon == "Linum bienne")$prediction[[1]]

# Order and relabel periods
climate_periods <- niche_prediction |>
  st_get_dimension_values("period") |>
  ordered(levels = c("LGM", "HS1", "BA", "YDS", "EH", "cur")) |>
  recode(
    "LGM" = "LGM (21 ka)",
    "HS1" = "HS1 (17.0-14.7 ka)",
    "BA"  = "BA (14.7-12.9 ka)",
    "YDS" = "YDS (12.9-11.7 ka)",
    "EH"  = "EH (11.7-8.3 ka)",
    "cur" = "current"
  )

niche_prediction <- st_set_dimensions(niche_prediction, "period", values = climate_periods)

ggplot() + 
  geom_stars(data = select(niche_prediction, prediction.TRUE.) > 0.5) +
  facet_wrap(~period, ncol = 3) +
  # scale_fill_batlow(reverse = TRUE) +
  coord_sf(crs = latlong) +
  labs(
    title = "Linum bienne",
    fill = NULL,
    x = NULL,
    y = NULL
  ) +
  theme_map() +
  theme(
    plot.title = element_text(face = "italic")
  )
```

### Comparison to archaeological occurrences

## Discussion

```{r sum-pred-eh}
flora |>
  mutate(pred_eh = map(fit, \(x) predict(climate$EH, model = x, type = "prob"))) ->
  x

pred_eh <- x$pred_eh
names(pred_eh) <- x$taxon
pred_eh <- do.call(c, map(pred_eh, select, .pred_TRUE))
pred_eh <- merge(pred_eh, name = "taxon")
sum_pred_eh <- st_apply(pred_eh, c("x", "y"), sum, na.rm = TRUE)
```

```{r fig-sum-pred-eh}
#| fig-cap: predicted species richness for the early Holocene
ggplot() + 
  geom_stars(data = sum_pred_eh) +
  scale_fill_batlow(reverse = FALSE) +
  coord_sf(crs = latlong) +
  labs(
    title = "Predicted species richness",
    subtitle = "Early Holocene (11.7–8.326 ka)",
    fill = NULL,
    x = NULL,
    y = NULL
  )

saveRDS(pred_eh, "pred_eh.Rdata")
```

```{r fig-pred-observed-eh}

```

## Acknowledgments {.appendix}
